# 4. RTPS Layer

*eProsima Fast DDS* 的低层 RTPS 层实现了 RTPS 标准中定义的协议。与 DDS 层相比，该层对通信协议内部细节提供了更多控制，因此高级用户能够更精细地掌控库的功能。

## 4.1. Relation to the DDS Layer

该层的元素与 DDS 层的元素一一对应，但包含少量附加项。对应关系如下表所示：

| DDS Layer | RTPS Layer |
| - | - |
| Domain | RTPSDomain |
| DomainParticipant | RTPSParticipant |
| DataWriter | RTPSWriter |
| DataReader | RTPSReader |

## 4.2. How to use the RTPS Layer

下面我们将像对 DDS 层那样，逐步介绍 RTPS 层的用法，并说明它带来的新特性。

建议在阅读本节时参考随发行版提供的示例 examples/cpp/rtps，该示例演示了如何使用 RTPS 层。

## 4.3. Configuring Readers and Writers

使用 RTPS 层的一个好处是，在保留 DDS 层选项的同时提供了新的配置可能性。例如，你可以像以前一样将 Writer 或 Reader 设置为 Reliable 或 Best-Effort 端点：

```
writer_attr.endpoint.reliabilityKind = BEST_EFFORT;
```

## 4.4. Configuring the History

History 有其自己的配置结构：`HistoryAttributes`。

## 4.5. Using a custom Payload Pool

*Payload* 定义为用户希望在 Writer 与 Reader 之间传输的数据。RTPS 需要为该 Payload 添加一些元数据以管理端点之间的通信。因此，该 Payload 被封装在 `CacheChange_t` 的 `SerializedPayload_t` 字段中，`CacheChange_t` 的其余字段则提供所需的元数据。

`WriterHistory` 与 `ReaderHistory` 为用户提供与这些更改交互的接口：要由 `Writer` 传输的更改会被添加到其 WriterHistory，而已在 Reader 端处理的更改可以从 ReaderHistory 中移除。从这个意义上，History 充当尚未被完全处理的更改的缓冲区。

在正常运行期间，新更改被添加到 History 中，旧更改则从中移除。为管理这些更改所包含的 Payload 的生命周期，Reader 和 Writer 使用一个池对象——即实现了 `IPayloadPool` 接口的实现。不同的池实现允许不同的优化，例如可以为不同大小的 Payload 从不同的预分配内存块中获取内存。

Writer 和 Reader 可以根据 `HistoryAttributes` 的配置自动选择最适合的默认 Payload 池实现。不过，也可以将自定义的 Payload 池传递给 `RTPSDomain::createRTPSWriter()` 和 `RTPSDomain::createRTPSReader()` 函数。Writer 与 Reader 在请求或释放新的 `CacheChange_t` 时会使用所提供的池。
