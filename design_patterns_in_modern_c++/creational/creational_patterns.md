# Creational Patterns

即使没有创建型模式，C++ 中对象的创建过程也充满了挑战。您应该在栈上还是堆上创建对象？这应该是一个原始指针、`unique_ptr`、`shared_ptr`，还是完全不同的东西？最后，手动创建对象是否仍然合适，或者我们应该将所有关键基础设施的创建委托给专门的构造，比如工厂（稍后会详细介绍）或控制反转容器？

无论选择哪种选项，对象的创建仍可能是一项繁琐的任务，尤其是在构建过程复杂或需要遵守特殊规则的情况下。这就是创建型模式的由来：它们是与对象创建相关的常见方法。

如果您对基础 `C++` 或智能指针有所生疏，以下是对 `C++` 中对象创建方式的简要回顾：

- *栈分配* 创建一个将在栈上分配的对象。该对象会在作用域结束时自动清理（您可以在任何地方使用一对大括号创建一个人工作用域）。如果将此对象赋值给一个变量，则该对象会在作用域结束时调用析构函数；如果不赋值，则析构函数会立即被调用。（这可能会破坏某些备忘录设计模式的实现，我们稍后会发现这一点。）
- *堆分配*使用原始指针进行堆分配会将对象放在堆上（也称为自由存储区）。`Foo* foo = new Foo;` 创建了一个新的 Foo 实例，并留下了谁负责清理对象的问题。GSL 中的 `owner<T>` 试图引入一些“所有权”的概念，但不涉及任何清理代码——您仍然必须自己编写。
- *unique_ptr* 可以接管堆分配的指针并管理它，以便在不再有引用指向它时自动清理。`unique_ptr`确实是唯一的：您不能复制它，并且在将其传递给另一个函数时会失去对原始指针的控制。
- *shared_ptr* 接管堆分配的指针并管理它，但允许代码中共享此指针。当没有任何组件持有该指针时，才会清理被拥有的指针。
- *weak_ptr* 是一个智能而非拥有的指针，持有一个由 `shared_ptr` 管理的对象的弱引用。为了实际访问引用的对象，您需要将其转换为 `shared_ptr`。它的用途之一是打破`shared_ptr` 之间的循环引用。

## Returning Objects From Functions

如果您返回的内容大于字长大小的值，有几种从函数返回的方式。第一种也是最明显的方式是：

```c++
Foo make_foo(int n)
{
  return Foo{n};
}
```

您可能会认为，根据上述方式，Foo的一个完整副本被创建了，从而浪费了宝贵的资源。但事实并非总是如此。假设您定义 `Foo` 如下：

```c++
struct Foo
{
  Foo(int n) {}
  Foo(const Foo&) { cout << "COPY CONSTRUCTOR!!!\n"; }
};
```

您会发现复制构造函数可能被调用零次到两次不等：确切的调用次数取决于编译器。返回值优化（Return Value Optimization, RVO）是编译器的一项特性，它专门用来防止这些额外的副本被创建（因为这些副本实际上不会影响代码的行为）。然而，在复杂场景中，您确实不能依赖RVO一定会发生。但在选择是否要优化返回值时，我更倾向于遵循 Knuth 的观点。

另一种方法当然是直接返回一个智能指针，例如 `unique_ptr`：

```c++
unique_ptr<Foo> make_foo(int n)
{
  return make_unique<Foo>(n);
}
```

这种方式非常安全，但也带有主观性：您为用户选择了智能指针。如果他们不喜欢智能指针怎么办？如果他们更倾向于使用 `shared_ptr` 呢？

第三种也是最后一种选项是使用原始指针，可能与GSL的 `owner<T>` 一起使用。这样，您不会强制清理分配的对象，但会非常明确地传达一个信息，即清理对象的责任在于调用者：

```c++
owner<Foo*> make_foo(int n)
{
  return new Foo(n);
}
```

您可以将这种方法视为给用户一个提示：我返回一个指针，从现在开始由您来负责处理这个指针。当然，现在调用 `make_foo()` 的代码需要处理这个指针：要么正确地调用 `delete`，要么将其包装在 `unique_ptr` 或 `shared_ptr`中。请记住，`owner<T>` 并不涉及复制的问题。

所有这些选项都是同样有效的，很难说哪个选项更好。
