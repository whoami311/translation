# Creational Patterns

即使没有创建型模式，C++ 中对象的创建过程也充满了挑战。您应该在栈上还是堆上创建对象？这应该是一个原始指针、`unique_ptr`、`shared_ptr`，还是完全不同的东西？最后，手动创建对象是否仍然合适，或者我们应该将所有关键基础设施的创建委托给专门的构造，比如工厂（稍后会详细介绍）或控制反转容器？

无论选择哪种选项，对象的创建仍可能是一项繁琐的任务，尤其是在构建过程复杂或需要遵守特殊规则的情况下。这就是创建型模式的由来：它们是与对象创建相关的常见方法。

如果您对基础 `C++` 或智能指针有所生疏，以下是对 `C++` 中对象创建方式的简要回顾：

- *栈分配* 创建一个将在栈上分配的对象。该对象会在作用域结束时自动清理（您可以在任何地方使用一对大括号创建一个人工作用域）。如果将此对象赋值给一个变量，则该对象会在作用域结束时调用析构函数；如果不赋值，则析构函数会立即被调用。（这可能会破坏某些备忘录设计模式的实现，我们稍后会发现这一点。）
- *堆分配*使用原始指针进行堆分配会将对象放在堆上（也称为自由存储区）。`Foo* foo = new Foo;` 创建了一个新的 Foo 实例，并留下了谁负责清理对象的问题。GSL 中的 `owner<T>` 试图引入一些“所有权”的概念，但不涉及任何清理代码——您仍然必须自己编写。
- *unique_ptr* 可以接管堆分配的指针并管理它，以便在不再有引用指向它时自动清理。`unique_ptr`确实是唯一的：您不能复制它，并且在将其传递给另一个函数时会失去对原始指针的控制。
- *shared_ptr* 接管堆分配的指针并管理它，但允许代码中共享此指针。当没有任何组件持有该指针时，才会清理被拥有的指针。
- *weak_ptr* 是一个智能而非拥有的指针，持有一个由 `shared_ptr` 管理的对象的弱引用。为了实际访问引用的对象，您需要将其转换为 `shared_ptr`。它的用途之一是打破`shared_ptr` 之间的循环引用。

## Returning Objects From Functions

如果您返回的内容大于字长大小的值，有几种从函数返回的方式。第一种也是最明显的方式是：

